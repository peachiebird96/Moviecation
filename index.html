<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Moviecation">
  <meta name="theme-color" content="#0b0f18" />
  <title>Moviecation</title>
  <style>
    :root{
      --bg:#0b0f18; --panel:#111827; --panel2:#0f172a;
      --text:#e5e7eb; --muted:#9ca3af; --line:#243041;
      --accent:#8b5cf6; --good:#22c55e; --bad:#ef4444; --warn:#f59e0b;
      --chip:#1f2937; --r:16px; --shadow:0 12px 30px rgba(0,0,0,.35);
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:var(--sans);background:linear-gradient(180deg,#070a12,var(--bg));color:var(--text)}
    header{position:sticky;top:0;z-index:10;background:rgba(11,15,24,.9);backdrop-filter:blur(10px);border-bottom:1px solid var(--line)}
    .wrap{max-width:1100px;margin:0 auto;padding:16px 16px 28px}
    h1{margin:4px 0 2px;font-size:22px}
    .sub{margin:0 0 10px;color:var(--muted);font-size:13px}
    .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--line);border-radius:var(--r);box-shadow:var(--shadow)}
    .toolbar{padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input, select, textarea{
      background:#0b1222;color:var(--text);border:1px solid #1f2a3a;border-radius:12px;
      padding:10px 12px;outline:none
    }
    input:focus, select:focus, textarea:focus{border-color:rgba(139,92,246,.8);box-shadow:0 0 0 3px rgba(139,92,246,.18)}
    .grow{flex:1;min-width:240px}
    .btn{border:1px solid #2a3550;background:#0b1222;color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;user-select:none;white-space:nowrap}
    .btn:hover{background:#0c1730;border-color:#3a4b72}
    .btn.primary{background:rgba(139,92,246,.18);border-color:rgba(139,92,246,.55)}
    .btn.good{background:rgba(34,197,94,.14);border-color:rgba(34,197,94,.5)}
    .btn.bad{background:rgba(239,68,68,.14);border-color:rgba(239,68,68,.5)}
    .btn.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.45)}
    .pill{font-size:12px;color:var(--muted);padding:6px 10px;border-radius:999px;border:1px solid #2a3550;background:#0b1222}
    main{padding:16px}
    .split{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;padding:12px 14px;border-top:1px solid var(--line);color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width:900px){.grid{grid-template-columns:1fr 1fr}}
    .item{padding:14px;display:flex;flex-direction:row;gap:10px;align-items:flex-start}
    .topline{display:flex;gap:10px;align-items:flex-start;justify-content:space-between}
    .title{font-size:16px;font-weight:700;line-height:1.25}
    .meta{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .chip{font-size:12px;background:var(--chip);border:1px solid #2b3a55;padding:5px 8px;border-radius:999px}
    .chip-link{display:inline-block;text-decoration:none; color:inherit}
    .chip-link .chip{cursor:pointer; color:var(--text) !important}
    .chip.vibe{color:#e9d5ff;border-color:rgba(139,92,246,.45)}
    .chip.service{color:#bbf7d0;border-color:rgba(34,197,94,.35)}
    .chip.buy{color:#fde68a;border-color:rgba(245,158,11,.35)}
    .chip.unk{color:#cbd5e1;border-color:#334155}
    .chip.watched{color:#bbf7d0;border-color:rgba(34,197,94,.55)}
    .chip.skipped{color:#fecaca;border-color:rgba(239,68,68,.55)}
    .chip.to_watch{color:#e5e7eb;border-color:rgba(139,92,246,.35)}
    /* clearer transparent backgrounds when status is final */
    .chip.watched{background:rgba(34,197,94,.08)}
    .chip.skipped{background:rgba(239,68,68,.06)}
    .chip.to_watch{background:rgba(139,92,246,.04)}
    .muted{color:var(--muted);font-size:13px}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    .modalWrap{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:16px;z-index:999}
    .modal{width:min(780px,100%);border-radius:18px;border:1px solid var(--line);background:linear-gradient(180deg,var(--panel),var(--panel2));box-shadow:var(--shadow)}
    .modal header{position:unset;background:transparent;border:none;padding:14px 16px 0}
    .modal h2{margin:0;font-size:18px}
    .modal .body{padding:14px 16px 16px}
    .results{display:grid;grid-template-columns:1fr;gap:10px}
    @media (min-width:720px){.results{grid-template-columns:1fr 1fr}}
    .pick{padding:12px;border:1px solid #2a3550;border-radius:14px;background:#0b1222;cursor:pointer}
    .pick:hover{border-color:#4c5d8a}
    .small{font-size:12px;color:var(--muted)}
    .hr{height:1px;background:var(--line);margin:12px 0}
  .results-summary{
  margin: 8px 2px 0;
  font-size: 13px;
  color: var(--muted);
}
  /* On small screens the toolbar can be very tall; disable sticky header so it scrolls away */
  @media (max-width:720px){
    header{position:static; top:auto; z-index:1}
  }
  /* Stack item contents on very small screens */
  @media (max-width:520px){
    .item{flex-direction:column}
  }
</style>
 
  <!-- Inline SVG favicon to avoid missing /favicon.ico  -->
  <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%230b0f18'/><text x='50' y='58' font-size='60' text-anchor='middle' fill='%23e5e7eb' font-family='Arial,Helvetica,sans-serif'>M</text></svg>">
</head>
<body>
<header>
  <div class="wrap">
    <div class="row" style="justify-content:space-between; align-items:flex-end;">
      <div>
        <h1>Moviecation</h1>
        <p class="sub">Type a title. We auto-categorize vibes + pull streaming services (US) and file it for you.</p>
      </div>
      <span class="pill" id="saveState">Saved ✓</span>
    </div>

    <div class="card toolbar">
      <div class="row">
        <input id="titleInput" class="grow" placeholder="Add by title only… (e.g., 'Twister', 'You’ve Got Mail')" />
        <button class="btn primary" id="autoAddBtn">Auto-Add</button>

        <input id="q" class="grow" placeholder="Search your list…" />
        <select id="statusFilter">
          <option value="all">All statuses</option>
          <option value="to_watch">To watch</option>
          <option value="watched">Watched</option>
          <option value="skipped">Skipped</option>
        </select>
        <select id="vibeFilter"><option value="all">All vibes</option></select>
        <select id="serviceFilter"><option value="all">All services</option></select>

        
        <button class="btn" id="clearFiltersBtn">Clear filters</button>
<button class="btn" id="exportBtn">Export</button>
        <button class="btn" id="importBtn">Import</button>
        <button class="btn warn" id="resetBtn">Reset</button>
      </div>
      <div id="resultsSummary" class="results-summary"></div>

      </div>
    </div>
  </div>
</header>

<div class="wrap">
  <main class="card" style="margin-top:14px">
    <div class="split">
      <div>
        <b id="kAll">0</b> total • <b id="kToWatch">0</b> to watch • <b id="kWatched">0</b> watched • <b id="kSkipped">0</b> skipped
      </div>
      <div class="small">Auto-saves on this device. Use Export to share/back up.</div>
    </div>
    <div class="grid" id="list"></div>
    <div class="split">
      <div class="small">Tip: iPhone Safari → Share → Add to Home Screen</div>
      <div class="small" id="ver"></div>
    </div>
  </main>
</div>

<!-- Pick result modal -->
<div class="modalWrap" id="pickWrap" aria-hidden="true">
  <div class="modal">
    <header>
      <h2>Pick the right title</h2>
      <p class="small">Sometimes multiple matches exist. Tap the correct one.</p>
    </header>
    <div class="body">
      <div class="results" id="pickResults"></div>
      <div class="hr"></div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="pickCancel">Cancel</button>
      </div>
    </div>
  </div>
</div>

<!-- Import/Export modal -->
<div class="modalWrap" id="ioWrap" aria-hidden="true">
  <div class="modal">
    <header>
      <h2 id="ioTitle">Export</h2>
      <p class="small">Export a JSON backup. Import will replace your current list.</p>
    </header>
    <div class="body">
      <textarea id="ioText" style="width:100%;min-height:220px;border-radius:14px" spellcheck="false"></textarea>
      <div class="row" style="justify-content:flex-end;margin-top:10px">
        <button class="btn" id="ioClose">Close</button>
        <button class="btn primary" id="ioDo">Download</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
(() => {
  // =========================
  // 1) PUT YOUR TMDB KEY HERE
  // =========================
  const TMDB_API_KEY = "1e07b8a005c4ee244fc4cf365bd49c49";
  const TMDB_REGION = "US"; // watch providers for US

  // ===== Supabase Sync (shared list, no login) =====
  // Paste from Supabase: Settings → API Keys → Publishable key
  const SUPABASE_URL = "https://fbiozabfithghkuldxgr.supabase.co";
  const SUPABASE_PUBLISHABLE_KEY = "sb_publishable_f_LdLwHeoEruDdwNtR77Yw_ceZw9e87";
  const LIST_ID = "11111111-1111-1111-1111-111111111111";

  const APP_VERSION = "2.0.0";
  const STORAGE_KEY = "moviecation:auto:v1";

  // Map TMDB genres -> your vibes (simple + good enough)
  // (We’re intentionally opinionated so she doesn’t have to think.)
  const VIBE_RULES = [
    { vibe: "Holiday / Seasonal", genres: ["Holiday"] }, // TMDB has no explicit Holiday genre; left here for future manual tagging
    { vibe: "Fantasy / Sci-Fi / Escape", genres: ["Fantasy","Science Fiction","Animation"] },
    { vibe: "Action / Adrenaline", genres: ["Action","Adventure","Thriller","Crime","War"] },
    { vibe: "Comedy / Easy", genres: ["Comedy"] },
    { vibe: "Emotional / Cry", genres: ["Drama","Romance"] },
    { vibe: "Dark / Gritty / Suspense", genres: ["Horror","Mystery","Thriller","Crime"] },
    { vibe: "Westerns / Americana", genres: ["Western"] },
    { vibe: "Coming-of-Age / Nostalgia", genres: ["Family","Music"] }, // family/music often feels “nostalgic/wholesome”
    { vibe: "Smart / Serious", genres: ["Documentary","History","Mystery"] },
    { vibe: "Disaster / Survival", genres: [] }, // detected via keywords fallback
    { vibe: "Cozy / Comfort", genres: [] }       // default fallback
  ];

  // Services you care about (we still store whatever TMDB returns, but these help filter + display)
  const CANON_SERVICES = [
    "Netflix","Hulu","Disney Plus","Disney+","Max","HBO Max","Prime Video","Amazon Prime Video","Peacock",
    "Paramount Plus","Paramount+","Apple TV","Apple TV+","YouTube","Google Play Movies","Fandango At Home",
    "Tubi TV","Pluto TV","Roku Channel","The Roku Channel"
  ];

// Apply current UI filters to a list of items and return the filtered array
function applyFilters(items){
  const q = (qEl.value || "").trim().toLowerCase();
  const status = (statusFilterEl.value || 'all').trim();
  const vibe = (vibeFilterEl.value || 'all').trim();
  const service = (serviceFilterEl.value || 'all').trim();

  console.debug('applyFilters called', { q, status, vibe, service, itemsCount: items.length });

  return items.filter(it => {
    if (status !== 'all' && String(it.status || '').trim() !== status) return false;
    if (vibe !== 'all' && String(it.vibe || '').trim() !== vibe) return false;
    if (service !== 'all'){
      if (!Array.isArray(it.services) || !it.services.some(s => String(s||'').trim() === service)) return false;
    }
    if (q){
      const hay = (`${it.title || ''} ${it.description || ''} ${(it.genres || []).join(' ')}`).toLowerCase();
      if (!hay.includes(q)) return false;
    }
    return true;
  });
}

  // Seed: start empty (since auto-add is the feature)
  let state = load() ?? { version: APP_VERSION, items: [] };

  const el = (id) => document.getElementById(id);
  el("ver").textContent = `v${APP_VERSION}`;

  const titleInput = el("titleInput");
  const autoAddBtn = el("autoAddBtn");
  const listEl = el("list");
  const qEl = el("q");
  const statusFilterEl = el("statusFilter");
  const vibeFilterEl = el("vibeFilter");
  const serviceFilterEl = el("serviceFilter");
  const saveStateEl = el("saveState");

  const clearFiltersBtn = el("clearFiltersBtn");
  const resultsSummaryEl = el("resultsSummary");

  const pickWrap = el("pickWrap");
  const pickResults = el("pickResults");
  const pickCancel = el("pickCancel");

  const ioWrap = el("ioWrap");
  const ioTitle = el("ioTitle");
  const ioText = el("ioText");
  const ioDo = el("ioDo");
  const ioClose = el("ioClose");

  let saveTimer = null;
  const UNDO_DURATION_MS = 8000; // 8 seconds
  const undoTimers = new Map(); // map itemId -> timeout

  function scheduleUndoForItem(it){
    if (!it || !it.id) return;
    // clear existing timer
    clearUndoTimer(it.id);
    const expires = Number(it._undoExpiresAt || 0);
    const ms = Math.max(0, expires - Date.now());
    if (ms <= 0){
      // already expired; clean up immediately
      delete it._prevStatus; delete it._prevUpdatedAt; delete it._undoExpiresAt;
      try{ saveSoon(); }catch(e){}
      return;
    }
    const t = setTimeout(() => {
      // expire undo window
      try{
        const idx = state.items.findIndex(x => x.id === it.id);
        if (idx >= 0){
          delete state.items[idx]._prevStatus;
          delete state.items[idx]._prevUpdatedAt;
          delete state.items[idx]._undoExpiresAt;
          saveSoon();
          render();
        }
      }catch(e){/* ignore */}
      undoTimers.delete(it.id);
    }, ms);
    undoTimers.set(it.id, t);
  }

  function clearUndoTimer(id){
    const ex = undoTimers.get(id);
    if (ex){ clearTimeout(ex); undoTimers.delete(id); }
  }

  function saveSoon(){
    saveStateEl.textContent = "Saving…";
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(async () => {
      // set updated timestamp
      state.updatedAt = Date.now();
      // Always keep local backup
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch(_) {}

      try{
        await saveRemoteState(state);
        saveStateEl.textContent = "Saved ✓";
      }catch(e){
        // If Supabase isn't configured yet, this will throw; that's OK.
        console.error(e);
        saveStateEl.textContent = "Saved ✓";
      }
    }, 250);
  }
  // Expose helpers for debugging/console use (safe, read-only accessor for state)
  try{
    window._supabase = _supabase;
    Object.defineProperty(window, '_appState', { get: () => state });
    window._saveSoon = () => { try{ saveSoon(); }catch(e){console.warn(e);} };
    window._initRemoteSync = () => { try{ initRemoteSync(); }catch(e){console.warn(e);} };
  }catch(e){ /* ignore in tightly locked environments */ }
  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    }catch(e){ return null; }
  }
  function id(){
    return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ("id-"+Math.random().toString(16).slice(2));
  }
  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }
  function showPick(on){
    pickWrap.style.display = on ? "flex" : "none";
    pickWrap.setAttribute("aria-hidden", on ? "false" : "true");
  }
  function showIO(on){
    ioWrap.style.display = on ? "flex" : "none";
    ioWrap.setAttribute("aria-hidden", on ? "false" : "true");
  }

  function normalizeServiceName(name){
    // Normalize a few common variants so sorting works
    const n = (name||"").trim();
    const low = n.toLowerCase();
    if (low === "disney plus") return "Disney+";
    if (low === "paramount plus") return "Paramount+";
    if (low === "amazon prime video") return "Prime Video";
    if (low === "tubi tv") return "Tubi";
    if (low === "pluto tv") return "Pluto TV";
    if (low === "the roku channel") return "Roku Channel";
    if (low === "fandango at home") return "Fandango At Home";
    return n;
  }

  function classifyServices(providerObj){
    // TMDB watch/providers returns: flatrate, rent, buy, ads, free
    // We store in a human way:
    // - Included: list of flatrate services (subscriptions)
    // - Otherwise: Rent/Buy if present
    const included = (providerObj?.flatrate || []).map(p => normalizeServiceName(p.provider_name));
    const ads = (providerObj?.ads || []).map(p => normalizeServiceName(p.provider_name));
    const free = (providerObj?.free || []).map(p => normalizeServiceName(p.provider_name));
    const rent = (providerObj?.rent || []).map(p => normalizeServiceName(p.provider_name));
    const buy = (providerObj?.buy || []).map(p => normalizeServiceName(p.provider_name));

    const services = [];
    for (const s of included) services.push(s);
    for (const s of free) services.push(s + " (Free)");
    for (const s of ads) services.push(s + " (Ads)");
    if (!services.length){
      if (rent.length || buy.length) services.push("Rent/Buy");
      else services.push("Unknown/Rent/Buy");
    }
    // unique
    return [...new Set(services)];
  }

  // Build provider-specific search/listing URLs for a title (best-effort).
  // Strategy: prefer Android `intent:` URIs (package-specific) when on Android,
  // otherwise use the provider's HTTPS universal link (which will open the app
  // on platforms where the provider has Universal Links/Associated Domains).
  // These are best-effort and may vary by OS/version — we fall back to a web search.
  const PROVIDER_URL_TEMPLATES = {
    'netflix': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.netflix.mediaclient;end`; return `https://www.netflix.com/search?q=${q}`; },
    'hulu': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.hulu.android;end`; return `https://www.hulu.com/search?query=${q}`; },
    'disney+': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.disney.disneyplus;end`; return `https://www.disneyplus.com/search?query=${q}`; },
    'disney plus': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.disney.disneyplus;end`; return `https://www.disneyplus.com/search?query=${q}`; },
    'max': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.hbo.hbonow;end`; return `https://www.hbomax.com/search?q=${q}`; },
    'hbo max': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.hbo.hbonow;end`; return `https://www.hbomax.com/search?q=${q}`; },
    'prime video': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.amazon.avod.thirdpartyclient;end`; return `https://www.amazon.com/s?k=${q}&i=instant-video`; },
    'amazon prime video': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.amazon.avod.thirdpartyclient;end`; return `https://www.amazon.com/s?k=${q}&i=instant-video`; },
    'peacock': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.peacock.android;end`; return `https://www.peacocktv.com/search?q=${q}`; },
    'paramount+': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.paramount.channel;end`; return `https://www.paramountplus.com/search/?q=${q}`; },
    'paramount plus': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=com.paramount.channel;end`; return `https://www.paramountplus.com/search/?q=${q}`; },
    'apple tv+': (t) => { const q = encodeURIComponent(t); return `https://tv.apple.com/us/search?term=${q}`; },
    'apple tv': (t) => { const q = encodeURIComponent(t); return `https://tv.apple.com/us/search?term=${q}`; },
    'youtube': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `vnd.youtube://results?search_query=${q}`; return `https://www.youtube.com/results?search_query=${q}`; },
    'google play movies': (t) => { const q = encodeURIComponent(t); return `https://play.google.com/store/search?q=${q}&c=movies`; },
    'fandango at home': (t) => { const q = encodeURIComponent(t); return `https://www.fandango.com/search?q=${q}`; },
    'tubi': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=tv.tubitv;end`; return `https://tubitv.com/search?query=${q}`; },
    'tubi tv': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=tv.tubitv;end`; return `https://tubitv.com/search?query=${q}`; },
    'pluto tv': (t) => { const q = encodeURIComponent(t); const isAndroid = (typeof navigator !== 'undefined') && /Android/i.test(navigator.userAgent); if (isAndroid) return `intent://search?q=${q}#Intent;package=tv.pluto.android;end`; return `https://pluto.tv/search?q=${q}`; },
    'roku channel': (t) => { const q = encodeURIComponent(t); return `https://therokuchannel.roku.com/search?search=${q}`; },
    'the roku channel': (t) => { const q = encodeURIComponent(t); return `https://therokuchannel.roku.com/search?search=${q}`; },
    'fandango': (t) => { const q = encodeURIComponent(t); return `https://www.fandango.com/search?q=${q}`; }
  };

  function getProviderSearchUrl(rawServiceName, title, year, tmdbType, tmdbId){
    const clean = String(rawServiceName || '').replace(/\s*\(.*\)$/, '').trim(); // drop (Free)/(Ads)
    const key = normalizeServiceName(clean).toLowerCase();
    // Build a cleaned title for searches: remove parenthetical years and trailing year fragments
    let raw = (title || '') + (year ? ' ' + year : '');
    try{
      // remove parenthetical years like "(1993)"
      raw = raw.replace(/\(\s*\d{4}\s*\)/g, '');
      // remove trailing year after dash/comma (e.g. "Title - 1993" or ", 1993")
      raw = raw.replace(/[-–—]\s*\d{4}$/, '').replace(/,\s*\d{4}$/, '');
      // if the explicit `year` param is present inside the title, remove the duplicate
      if (year){ raw = raw.replace(new RegExp('\\b' + String(year) + '\\b'), ''); }
      raw = raw.replace(/\s+/g, ' ').trim();
    }catch(e){ /* fallback to unmodified raw on any error */ }
    // If we have a TMDB id for this item, prefer linking to that TMDB detail page (specific title)
    if (tmdbId && tmdbType){
      return `https://www.themoviedb.org/${tmdbType}/${encodeURIComponent(String(tmdbId))}`;
    }

    if (PROVIDER_URL_TEMPLATES[key]) return PROVIDER_URL_TEMPLATES[key](raw);
    // fallback: JustWatch search
    return `https://www.justwatch.com/us/search?q=${encodeURIComponent(raw)}`;
  }

  // ------------------
  // Supabase cross-device sync
  // ------------------
  const _supabase = (window.supabase && window.supabase.createClient) ? window.supabase.createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY) : null;
  // If realtime is available, subscribe to changes on the table so other devices push updates to us
  if (_supabase && typeof _supabase.channel === 'function'){
    try{
      // Merge helper used for realtime incoming payloads — prefers newer per-item data
      const mergeStatesForRealtime = (localS, remoteS) => {
        if (!remoteS) return localS;
        const out = { version: localS.version || remoteS.version || APP_VERSION, items: [] };
        const map = new Map();
        const add = (it) => map.set(it.key, Object.assign({}, map.get(it.key) || {}, it));

        for (const r of (remoteS.items || [])) add(r);

        for (const l of (localS.items || [])){
          const existing = map.get(l.key) || null;
          if (!existing){ add(l); continue; }
          const rUpdated = Number(existing.updatedAt || 0);
          const lUpdated = Number(l.updatedAt || 0);
          const newer = lUpdated >= rUpdated ? l : existing;
          const older = lUpdated >= rUpdated ? existing : l;
          const merged = Object.assign({}, older, newer);
          if ((!newer.description || String(newer.description).trim() === '') && older && older.description) merged.description = older.description;
          if ((!newer.poster_path || String(newer.poster_path).trim() === '') && older && older.poster_path) merged.poster_path = older.poster_path;
          merged.createdAt = older.createdAt || newer.createdAt || Date.now();
          merged.updatedAt = Math.max(rUpdated, lUpdated, Date.now());
          map.set(merged.key, merged);
        }

        out.items = Array.from(map.values());
        out.updatedAt = Math.max(Number(localS.updatedAt||0), Number(remoteS.updatedAt||0), Date.now());
        return out;
      };

      const movieChannel = _supabase.channel('public:movie_lists')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'movie_lists' }, (payload) => {
          try{
            const remote = payload?.new?.data;
            if (!remote) return;
            const merged = mergeStatesForRealtime(state, remote);
            const rU = merged.updatedAt || Math.max(0, ...(merged.items||[]).map(i=>i.updatedAt||0));
            const lU = state.updatedAt || Math.max(0, ...(state.items||[]).map(i=>i.updatedAt||0));
            if (rU > lU){
              state = merged;
              try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(_){ }
              render();
            }
          }catch(e){ console.warn('realtime payload handling failed', e); }
        })
        .subscribe();

      // expose channel for potential teardown
      window._movieChannel = movieChannel;
    }catch(e){ console.warn('realtime subscribe failed', e); }
  }

  async function saveRemoteState(st){
    if (!_supabase) return;
    try{
      // Load remote state and merge to avoid clobbering metadata like description/poster_path
      let remote = null;
      try{ remote = await loadRemoteState(); }catch(_){}

      const mergeStates = (localS, remoteS) => {
        if (!remoteS) return localS;
        const out = { version: localS.version || remoteS.version || APP_VERSION, items: [] };
        const map = new Map();
        const add = (it) => map.set(it.key, Object.assign({}, map.get(it.key) || {}, it));

        // index remote items first
        for (const r of (remoteS.items || [])) add(r);

        // merge local items, preferring newer per-item fields but preserving older description/poster when newer lacks them
        for (const l of (localS.items || [])){
          const existing = map.get(l.key) || null;
          if (!existing){
            add(l);
            continue;
          }
          const rUpdated = Number(existing.updatedAt || 0);
          const lUpdated = Number(l.updatedAt || 0);
          const newer = lUpdated >= rUpdated ? l : existing;
          const older = lUpdated >= rUpdated ? existing : l;
          const merged = Object.assign({}, older, newer);
          // if newer lacks description/poster, keep older's values
          if ((!newer.description || String(newer.description).trim() === '') && older && older.description) merged.description = older.description;
          if ((!newer.poster_path || String(newer.poster_path).trim() === '') && older && older.poster_path) merged.poster_path = older.poster_path;
          merged.createdAt = older.createdAt || newer.createdAt || Date.now();
          merged.updatedAt = Math.max(rUpdated, lUpdated, Date.now());
          map.set(merged.key, merged);
        }

        out.items = Array.from(map.values());
        out.updatedAt = Math.max(Number(localS.updatedAt||0), Number(remoteS.updatedAt||0), Date.now());
        return out;
      };

      // If local state is newer (e.g. a recent local delete), prefer it wholesale
      // to avoid resurrecting removed items from an older remote copy.
      const payloadState = (
        !remote || Number(st.updatedAt || 0) >= Number(remote.updatedAt || 0)
      ) ? st : mergeStates(st, remote);

      // Prefer RPC, but send merged payload so we don't wipe metadata
      if (typeof _supabase.rpc === 'function'){
        const { error } = await _supabase.rpc('upsert_movie_list', { p_id: LIST_ID, p_data: payloadState });
        if (error) throw error;
        return;
      }

      const payload = { id: LIST_ID, data: payloadState, updated_at: new Date().toISOString() };
      const { error } = await _supabase.from('movie_lists').upsert(payload, { returning: 'minimal' });
      if (error) throw error;
    }catch(e){
      console.warn('saveRemoteState failed', e);
      throw e;
    }
  }

  async function loadRemoteState(){
    if (!_supabase) return null;
    try{
      const { data, error } = await _supabase.from('movie_lists').select('data').eq('id', LIST_ID).single();
      if (error){
        console.warn('loadRemoteState error', error);
        return null;
      }
      return data?.data || null;
    }catch(e){
      console.warn('loadRemoteState failed', e);
      return null;
    }
  }

  async function initRemoteSync(){
    if (!_supabase) return;
    try{
      const remote = await loadRemoteState();
      if (!remote){
        // push local state to remote if nothing exists
        await saveRemoteState(state);
        return;
      }

      const localUpdated = state.updatedAt || Math.max(0, ...(state.items||[]).map(i=>i.createdAt||0));
      const remoteUpdated = remote.updatedAt || Math.max(0, ...(remote.items||[]).map(i=>i.createdAt||0));

      if (remoteUpdated > localUpdated){
        state = remote;
        try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){}
        render();
      } else if (localUpdated > remoteUpdated){
        await saveRemoteState(state);
      }

      // Poll for remote changes (simple fallback when realtime isn't configured)
      setInterval(async () => {
        try{
          const r = await loadRemoteState();
          if (!r) return;
          const rU = r.updatedAt || Math.max(0, ...(r.items||[]).map(i=>i.createdAt||0));
          const lU = state.updatedAt || Math.max(0, ...(state.items||[]).map(i=>i.createdAt||0));
          if (rU > lU){
            state = r;
            try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){}
            render();
          }
        }catch(e){/* ignore polling errors */}
      }, 15000);

    }catch(e){ console.warn('initRemoteSync failed', e); }
  }

  function vibeFromGenres(genres, title){
    const gset = new Set((genres||[]).map(g => g.name));
    const t = (title||"").toLowerCase();

    // Disaster-ish keyword fallback
    const disasterWords = ["volcano","earthquake","tornado","storm","hurricane","tsunami","disaster","apocalypse","survival"];
    if (disasterWords.some(w => t.includes(w))) return "Disaster / Survival";

    // Apply rules in order
    for (const rule of VIBE_RULES){
      if (!rule.genres.length) continue;
      if (rule.genres.some(g => gset.has(g))) return rule.vibe;
    }

    // If horror present (often overlap), push to Dark/Gritty
    if (gset.has("Horror")) return "Dark / Gritty / Suspense";

    // If drama/romance heavy, emotional
    if (gset.has("Drama") || gset.has("Romance")) return "Emotional / Cry";

    // If comedy present, easy
    if (gset.has("Comedy")) return "Comedy / Easy";

    // Default
    return "Cozy / Comfort";
  }

  async function tmdb(path, params={}){
    if (!TMDB_API_KEY || TMDB_API_KEY.includes("PASTE_")){
      throw new Error("TMDB API key is missing. Paste your key into TMDB_API_KEY in the HTML file.");
    }
    const url = new URL("https://api.themoviedb.org/3" + path);
    url.searchParams.set("api_key", TMDB_API_KEY);
    for (const [k,v] of Object.entries(params)){
      if (v !== undefined && v !== null && v !== "") url.searchParams.set(k, v);
    }
    const res = await fetch(url.toString());
    if (!res.ok){
      const txt = await res.text().catch(()=> "");
      throw new Error(`TMDB error ${res.status}: ${txt.slice(0,120)}`);
    }
    return res.json();
  }

  async function autoAddTitle(title){
    const q = title.trim();
    if (!q) return;

    // Search both movie and TV; movie first by default
    const movie = await tmdb("/search/movie", { query: q, include_adult: "false", language:"en-US" });
    const tv = await tmdb("/search/tv", { query: q, include_adult: "false", language:"en-US" });

    const candidates = [];
    for (const m of (movie.results || []).slice(0, 6)){
      candidates.push({ kind:"movie", id:m.id, name:m.title, year:(m.release_date||"").slice(0,4), overview:m.overview });
    }
    for (const s of (tv.results || []).slice(0, 6)){
      candidates.push({ kind:"tv", id:s.id, name:s.name, year:(s.first_air_date||"").slice(0,4), overview:s.overview });
    }

    if (!candidates.length){
      alert("No matches found. Try a slightly different title.");
      return;
    }

    // If top match is very confident, skip pick UI; otherwise show picker
    // (Simple heuristic: exact-ish title match on first result)
    const top = candidates[0];
    const exactish = top.name.toLowerCase() === q.toLowerCase();

    if (exactish || candidates.length === 1){
      await addFromCandidate(top);
    } else {
      await pickCandidate(candidates);
    }
  }

  async function pickCandidate(cands){
    pickResults.innerHTML = cands.map(c => `
      <div class="pick" data-kind="${esc(c.kind)}" data-id="${esc(String(c.id))}">
        <div><b>${esc(c.name)}</b> <span class="small">${esc(c.year || "")} • ${c.kind === "tv" ? "TV" : "Movie"}</span></div>
        <div class="small">${esc((c.overview||"").slice(0,120))}${(c.overview||"").length>120 ? "…" : ""}</div>
      </div>
    `).join("");
    showPick(true);

    return new Promise((resolve) => {
      const cleanup = () => {
        pickResults.querySelectorAll(".pick").forEach(p => p.removeEventListener("click", onPick));
        pickCancel.removeEventListener("click", onCancel);
      };
      const onPick = async (e) => {
        const box = e.currentTarget;
        const kind = box.getAttribute("data-kind");
        const id = box.getAttribute("data-id");
        cleanup();
        showPick(false);
        const chosen = cands.find(x => x.kind === kind && String(x.id) === String(id));
        if (chosen) await addFromCandidate(chosen);
        resolve();
      };
      const onCancel = () => {
        cleanup();
        showPick(false);
        resolve();
      };

      pickResults.querySelectorAll(".pick").forEach(p => p.addEventListener("click", onPick));
      pickCancel.addEventListener("click", onCancel);
    });
  }

  async function addFromCandidate(c){
    // Fetch details + watch providers
    let details, providers;
    if (c.kind === "movie"){
      details = await tmdb(`/movie/${c.id}`, { language:"en-US" });
      providers = await tmdb(`/movie/${c.id}/watch/providers`);
    } else {
      details = await tmdb(`/tv/${c.id}`, { language:"en-US" });
      providers = await tmdb(`/tv/${c.id}/watch/providers`);
    }

    const region = providers?.results?.[TMDB_REGION];
    const services = classifyServices(region);

    const title = c.kind === "movie" ? details.title : details.name;
    const year = c.kind === "movie" ? (details.release_date||"").slice(0,4) : (details.first_air_date||"").slice(0,4);
    const genres = details.genres || [];
    const vibe = vibeFromGenres(genres, title);

    // Avoid duplicates by title+year+kind
    const key = `${c.kind}:${title.toLowerCase()}:${year||""}`;
    const exists = state.items.some(it => it.key === key);
    if (exists){
      alert("Already in the list.");
      return;
    }

    state.items.push({
      id: id(),
      key,
      type: c.kind === "tv" ? "show" : "movie",
      status: "to_watch",
      title,
      year,
      vibe: vibeFromGenres(genres, title),
      services,
      genres: genres.map(g=>g.name),
      tmdbId: details.id,
      tmdbType: c.kind === "movie" ? 'movie' : 'tv',
      createdAt: Date.now()
    });
    saveSoon();
  }

  async function addFromCandidate(c){
    let details, providers;
    const typePath = c.kind === "movie" ? "movie" : "tv";
    details = await tmdb(`/${typePath}/${c.id}`, { language:"en-US" });
    providers = await tmdb(`/${typePath}/${c.id}/watch/providers`);

    const region = providers?.results?.[TMDB_REGION];
    const services = classifyServices(region);

    const title = c.kind === "movie" ? details.title : details.name;
    const year = c.kind === "movie" ? (details.release_date||"").slice(0,4) : (details.first_air_date||"").slice(0,4);
    const key = `${c.kind}:${title.toLowerCase()}:${year||""}`;
    if (state.items.some(it => it.key === key)){
      alert("Already in the list."); return;
    }

    state.items.push({
      id: id(),
      key,
      type: c.kind === "tv" ? "show" : "movie",
      status: "to_watch",
      title,
      year,
      vibe: vibeFromGenres(details.genres || [], title),
      services,
      description: details.overview,
      poster_path: details.poster_path,
      genres: (details.genres || []).map(g=>g.name),
      tmdbId: details.id,
      tmdbType: c.kind === "movie" ? 'movie' : 'tv',
      createdAt: Date.now(),
      updatedAt: Date.now()
    });
    saveSoon(); render();
    titleInput.value = "";
  }

  function setOptions(){
    // Populate vibe and service filters from current items
    const vibes = new Set();
    const services = new Set();
    for (const it of state.items){
      if (it.vibe) vibes.add(it.vibe);
      for (const s of (it.services||[])) services.add(s);
    }
    // Rebuild options, preserving 'all'
    const make = (selEl, set) => {
      const prev = selEl.value || 'all';
      selEl.innerHTML = `<option value="all">All ${selEl === vibeFilterEl ? 'vibes' : 'services'}</option>` +
        [...set].sort().map(s => `<option value="${esc(s)}">${esc(s)}</option>`).join('');
      // Restore previous selection only if it exists in the rebuilt options
      const hasPrev = Array.from(selEl.options).some(o => String(o.value) === String(prev));
      selEl.value = hasPrev ? prev : 'all';
    };
    make(vibeFilterEl, vibes);
    make(serviceFilterEl, services);

    // Summary
    resultsSummaryEl.textContent = `${state.items.length} items`;
    console.debug('setOptions populated', { vibes: [...vibes], services: [...services] });
  }

  function render(){
    try{ setOptions(); }catch(e){}
    const all = state.items.length;
    const toWatch = state.items.filter(x=>x.status==="to_watch").length;
    const watched = state.items.filter(x=>x.status==="watched").length;
    const skipped = state.items.filter(x=>x.status==="skipped").length;
    el("kAll").textContent = all;
    el("kToWatch").textContent = toWatch;
    el("kWatched").textContent = watched;
    el("kSkipped").textContent = skipped;

    // Apply filters, show counts, then sort newest-first
    const filtered = (typeof applyFilters === 'function' ? applyFilters(state.items.slice()) : state.items.slice());
    const activeParts = [];
    const stVal = (statusFilterEl.value || 'all').trim();
    const vbVal = (vibeFilterEl.value || 'all').trim();
    const svVal = (serviceFilterEl.value || 'all').trim();
    const qVal = (qEl.value || '').trim();
    if (stVal !== 'all') activeParts.push(`status: ${stVal}`);
    if (vbVal !== 'all') activeParts.push(`vibe: ${vbVal}`);
    if (svVal !== 'all') activeParts.push(`service: ${svVal}`);
    if (qVal) activeParts.push(`q: "${qVal}"`);
    resultsSummaryEl.textContent = activeParts.length ? `${filtered.length} / ${state.items.length} — ${activeParts.join(', ')}` : `${filtered.length} / ${state.items.length}`;
    console.debug('Filters:', { q: qEl.value, status: statusFilterEl.value, vibe: vibeFilterEl.value, service: serviceFilterEl.value, filtered: filtered.length });

    const items = filtered.sort((a,b) => Number(b.createdAt || b.updatedAt || 0) - Number(a.createdAt || a.updatedAt || 0));

    listEl.innerHTML = items.map(it => {
        const svcChips = (it.services||[]).map(s => {
          const url = getProviderSearchUrl(s, it.title, it.year, it.type, it.tmdbId);
          return `<a class="chip-link" href="${url}" target="_blank" rel="noopener noreferrer"><span class="chip service">${esc(s)}</span></a>`;
        }).join("");
        const posterImg = it.poster_path 
          ? `<img src="https://image.tmdb.org/t/p/w200${it.poster_path}" style="width:90px; height:135px; border-radius:10px; box-shadow: var(--shadow); object-fit:cover; display:block">` 
          : `<div style="width:90px; height:135px; background:var(--chip); border-radius:10px; display:flex; align-items:center; justify-content:center; text-align:center; font-size:11px; color:var(--muted)">No Image</div>`;

      let actionButtons = '';
      // If we have a recorded previous status, offer an Undo button
      if (it._prevStatus !== undefined && it._prevStatus !== null){
        const rem = Math.max(0, Math.ceil(((Number(it._undoExpiresAt) || 0) - Date.now())/1000));
        actionButtons = `<div class="actions" style="margin-top:12px">
             <button class="btn" data-undo="${it.id}">Undo${rem ? ' ('+rem+'s)' : ''}</button>
           </div>`;
      } else if (String(it.status || '') !== 'watched' && String(it.status || '') !== 'skipped'){
        actionButtons = `<div class="actions" style="margin-top:12px">
             <button class="btn good" data-set="${it.id}" data-to="watched">Watched</button>
             <button class="btn bad" data-set="${it.id}" data-to="skipped">Skip</button>
           </div>`;
      }

      // Compute display label + status chip classes
      const statusLabel = (it.status === 'to_watch') ? 'To Watch' : (it.status ? (String(it.status).charAt(0).toUpperCase() + String(it.status).slice(1)) : 'To Watch');
      const statusChipClasses = (() => {
        let c = 'chip';
        if (it.status === 'watched') c += ' watched';
        else if (it.status === 'skipped') c += ' skipped';
        else c += ' to_watch';
        return c;
      })();

      return `
        <div class="card item" style="display:flex; gap:15px; align-items:flex-start; padding:15px;">
          <div style="flex:0 0 90px;">
            ${posterImg}
          </div>
          <div style="flex:1; min-width:0;">
            <div class="topline">
              <div class="title">${esc(it.title)} <span class="muted" style="font-weight:400">(${esc(it.year)})</span></div>
              <button class="btn" data-del="${it.id}">×</button>
            </div>
            <div class="meta" style="margin:6px 0">
              <span class="${statusChipClasses}">${esc(statusLabel)}</span>
              <span class="chip vibe">${esc(it.vibe)}</span>
            </div>
            <p style="font-size:13px; color:var(--muted); line-height:1.4; margin:8px 0">${esc(it.description || "No description available.")}</p>
            <div class="meta" style="gap:6px">${svcChips}</div>
            ${actionButtons}
          </div>
        </div>
      `;
    }).join("");

    // Wire up the status-change buttons (Watched / Skip)
    listEl.querySelectorAll("[data-set]").forEach(b => b.addEventListener("click", () => {
      const idv = b.getAttribute("data-set");
      const it = state.items.find(x=>x.id===idv);
        if(it){
          // record previous status so we can undo
          try{ it._prevStatus = it.status === undefined || it.status === null ? 'to_watch' : it.status; }catch(e){ it._prevStatus = 'to_watch'; }
          try{ it._prevUpdatedAt = it.updatedAt || Date.now(); }catch(e){ it._prevUpdatedAt = Date.now(); }
          it.status = b.getAttribute("data-to");
          it.updatedAt = Date.now();
          // Set undo expiry and schedule cleanup
          it._undoExpiresAt = Date.now() + UNDO_DURATION_MS;
          saveSoon(); render();
          try{ scheduleUndoForItem(it); }catch(e){/* ignore */}
        }
    }));
    // Wire up Undo buttons
    listEl.querySelectorAll("[data-undo]").forEach(b => b.addEventListener("click", () => {
      const idv = b.getAttribute("data-undo");
      const it = state.items.find(x=>x.id===idv);
      if (it && (it._prevStatus !== undefined)){
        // clear any pending auto-expire timer
        try{ clearUndoTimer(it.id); }catch(e){}
        it.status = it._prevStatus || 'to_watch';
        it.updatedAt = it._prevUpdatedAt || Date.now();
        delete it._prevStatus;
        delete it._prevUpdatedAt;
        delete it._undoExpiresAt;
        saveSoon(); render();
      }
    }));
    listEl.querySelectorAll("[data-del]").forEach(b => b.addEventListener("click", () => {
      const idv = b.getAttribute("data-del");
      const it = state.items.find(x=>x.id===idv);
      if (it && confirm(`Delete "${it.title}"?`)){
        state.items = state.items.filter(x=>x.id!==idv); saveSoon(); render();
      }
    }));
    // Ensure timers exist for any pending undos (handles reloads and re-renders)
    try{
      state.items.forEach(it => {
        if (it && it._prevStatus !== undefined && it._undoExpiresAt && !undoTimers.has(it.id)){
          scheduleUndoForItem(it);
        }
      });
    }catch(e){}
  }

  // Import/Export
  function openIO(mode){
    ioTitle.textContent = mode === "export" ? "Export" : "Import";
    if (mode === "export"){
      ioText.value = JSON.stringify(state, null, 2);
      ioDo.textContent = "Download";
      ioDo.onclick = () => {
        const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "moviecation.json";
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      };
    } else {
      ioText.value = "";
      ioDo.textContent = "Import (Replace)";
      ioDo.onclick = () => {
        try{
          const incoming = JSON.parse(ioText.value);
          if (!incoming || !Array.isArray(incoming.items)) throw new Error("Invalid JSON");
          // minimal normalize, include per-item updatedAt
          state = { version: APP_VERSION, items: incoming.items.map(x => ({
            id: x.id || id(),
            key: x.key || `${x.type}:${(x.title||"").toLowerCase()}:${x.year||""}`,
            type: x.type === "show" ? "show" : "movie",
            status: ["to_watch","watched","skipped"].includes(x.status) ? x.status : "to_watch",
            title: x.title || "Untitled",
            year: x.year || "",
            vibe: x.vibe || "Cozy / Comfort",
            services: Array.isArray(x.services) ? x.services : ["Unknown/Rent/Buy"],
            genres: Array.isArray(x.genres) ? x.genres : [],
            createdAt: x.createdAt || Date.now(),
            updatedAt: x.updatedAt || x.createdAt || Date.now()
          }))};
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          showIO(false); render();
          alert("Imported!");
        }catch(e){
          alert("Import failed: " + (e.message || e));
        }
      };
    }
    showIO(true);
  }

  function resetAll(){
    if (!confirm("Reset and erase your current list on this device?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state = { version: APP_VERSION, items: [] };
    render();
  }

  // Events
  autoAddBtn.addEventListener("click", async () => {
    try{
      autoAddBtn.disabled = true;
      autoAddBtn.textContent = "Adding…";
      await autoAddTitle(titleInput.value);
    }catch(e){
      alert(e.message || String(e));
    }finally{
      autoAddBtn.disabled = false;
      autoAddBtn.textContent = "Auto-Add";
    }
  });
  titleInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") autoAddBtn.click();
  });

  pickWrap.addEventListener("click", (e) => { if (e.target === pickWrap) showPick(false); });
  pickCancel.addEventListener("click", () => showPick(false));

  el("exportBtn").addEventListener("click", () => openIO("export"));
  el("importBtn").addEventListener("click", () => openIO("import"));
  ioClose.addEventListener("click", () => showIO(false));
  ioWrap.addEventListener("click", (e) => { if (e.target === ioWrap) showIO(false); });

  el("resetBtn").addEventListener("click", resetAll);

  qEl.addEventListener("input", render);

[statusFilterEl, vibeFilterEl, serviceFilterEl].forEach(x => {
  x.addEventListener("change", (e) => { console.debug('filter changed', { id: e.currentTarget.id, value: e.currentTarget.value }); render(); });
});

  // Clear filters
  if (clearFiltersBtn){
    clearFiltersBtn.addEventListener("click", () => {
      qEl.value = "";
      statusFilterEl.value = "all";
      vibeFilterEl.value = "all";
      serviceFilterEl.value = "all";
      render();
    });
  }



  render();
  // Start remote sync in background (if Supabase is configured)
  try{ initRemoteSync(); }catch(e){}
})();
</script>
</body>
</html>
